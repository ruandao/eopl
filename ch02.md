exercise 2.1
  (define (zero)
    '())
  (define (successor n)
    (if (null? n)
        '(1)
        (if (= N (+ 1 (car n)))
          (cons 0 (successor (cdr n)))
          (cons (+ 1 (car n)) (cdr n ))))))
  (define (predecessor n)
    (if (null? n)
        (report-error)
        (if (= 0 (car n))
            (cons (- N 1) (predecessor (cdr n)))
            (cons (- (car n) 1) (cdr n)))))
  (define (is-zero? n)
    (null? n))
  (define (mul n m)
    (if (is-zero? m)
        (zero)
        (plus n (mul n (predecessor m)))))
  (define (factorial n)
    (if (is-zero (predecessor n))))

exercise 2.4
  (define empty-stack
    (lambda ()
      '()))
  (define (empty-stack? s)
    (null? s))
  (define (push s v)
    (cons v s))
  (define (pop s)
    (cdr s))
  (define (top s)
    (car s))
  observers: empty-stack?, top
  constructors: empty-stack, push, pop

exercise 2.5
  (define (empty-env)
    '())
  (define (exten-env var val env)
    (cons (cons var val)
          env))
  (define (apply-env env search-var)
    (cond ((empty-env? env) report-error)
          (else (let ((save-var (car (car env)))
                      (save-val (cdr (car env)))
                      (save-env (cdr env)))
                    (if (eqv? save-var search-var)
                        save-val)
                        (apply-env save-env search-var)))))
  (define (empty-env? env)
    (null? env))
