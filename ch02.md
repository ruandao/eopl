exercise 2.1
  (define (zero)
    '())
  (define (successor n)
    (if (null? n)
        '(1)
        (if (= N (+ 1 (car n)))
          (cons 0 (successor (cdr n)))
          (cons (+ 1 (car n)) (cdr n ))))))
  (define (predecessor n)
    (if (null? n)
        (report-error)
        (if (= 0 (car n))
            (cons (- N 1) (predecessor (cdr n)))
            (cons (- (car n) 1) (cdr n)))))
  (define (is-zero? n)
    (null? n))
  (define (mul n m)
    (if (is-zero? m)
        (zero)
        (plus n (mul n (predecessor m)))))
  (define (factorial n)
    (if (is-zero (predecessor n))))

exercise 2.4
  (define empty-stack
    (lambda ()
      '()))
  (define (empty-stack? s)
    (null? s))
  (define (push s v)
    (cons v s))
  (define (pop s)
    (cdr s))
  (define (top s)
    (car s))
  observers: empty-stack?, top
  constructors: empty-stack, push, pop

exercise 2.5
  (define (empty-env)
    '())
  (define (exten-env var val env)
    (cons (cons var val)
          env))
  (define (apply-env env search-var)
    (cond ((empty-env? env) report-error)
          (else (let ((save-var (car (car env)))
                      (save-val (cdr (car env)))
                      (save-env (cdr env)))
                    (if (eqv? save-var search-var)
                        save-val)
                        (apply-env save-env search-var)))))
  (define (empty-env? env)
    (null? env))

exercise 2.6
  (define (empty-env)
    '()
  (define (extend-env var val env)
    (cons env
          (cons var val))))
  (define (apply-env env search-var)
    (cond ((empty-env? env) report-error)
          (else (let ((save-env (car env))
                      ((save-var (car (cdr env)))
                      ((save-val (cdr (cdr env))))
                    (if (eqv? save-var search-var)
                          save-val)
                          apply-env save-env search-var)))))


exercise 2.7
  (define apply-env
    (lambda (env search-var)
      (cond
        ((eqv? (car env) 'empty-env)
          (report-no-binding-found search-var))
        ((eqv? (car env) 'extend-env)
          (let ((saved-var (cadr env))
                (saved-val (caddr env))
                (saved-env (cadddr env)))
              (if (eqv? search-var saved-var)
                  saved-val
                  (apply-env saved-env search-var))))
        (else
          (report-invalid-env env)))))

exercise 2.8
  (define (empty-env? env)
    (null? env))

exercise 2.9
  (define (has-binding? env s)
    (if (empty-env? env)
        #f
        (let ((saved-var (get-var env))
              (saved-env (get-env env)))
          (if (eqv? saved-var s)
              #t
              (has-binding saved-env s)))))

exercise 2.10
  (define (extend-env* vars vals env)
    (if (null? vars)
        env
        (cons (list (car vars)
                    (car vals))
              (extend-env* (cdr vars)
                           (cdr vals)
                           env))))

exercise 2.11
  (define (extend-env* vars vals env)
    (cons (cons vars vals)
          env))

exercise 2.12
  (define (empty-stack)
    (lambda (action)
      (if (eqv? action 'empty-stack?)
          #t
          (report-empty-error)))
  (define (push s var)
    (lambda (action)
      (cond
        ((eqv? action 'top)
          var)
        ((eqv? action 'pop)
          s)
        ((eqv? action 'empty-stack?)
          #f)
        (else report-error))))
    (define (pop s)
      (s 'pop))
    (define (top s)
      (s 'top))
    (define (empty-stack? s)
      (s 'empty-stack?)
      )

exercise 2.13
  (define (empty-env? env)
    (cons (lambda(var)
            report-error)
          (lambda()
            #t)))
  (define (extend-env var val env)
    (cons (lambda(search-var)
            (if (eqv? var search-var)
                val
                (apply-env env search-var)))
          (lambda()
            #f)))
  (define (apply-env env search-var)
    ((get-search env) search-var))
  (define (get-search env)
    (car env))
